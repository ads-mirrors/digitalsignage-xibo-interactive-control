{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/xibo-interactive-control.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","window","xiboIC","_lib","protocol","hostName","port","headers","timelimit","callbackQueue","isVisible","isPreview","targetId","xiboICTargetId","undefined","getOriginURL","this","makeRequest","path","_ref","arguments","length","type","data","done","error","parent","previewActionTrigger","status","responseText","urlToUse","typeToUse","reqHeaders","xhr","XMLHttpRequest","timeout","open","setRequestHeader","forEach","header","newData","_typeof","JSON","stringify","onload","send","_IPC","_callback","previewData","messageHandler","evt","ctrl","notifyData","dataKey","console","log","registerIPC","addEventListener","BroadcastChannel","event","mainLib","setTargetId","checkVisible","$","urlParam","results","RegExp","exec","location","href","decodeURI","checkIsPreview","URLSearchParams","searchParams","search","has","config","_ref2","info","_ref3","trigger","code","_ref4","id","expireNow","_ref5","extendWidgetDuration","duration","_ref6","setWidgetDuration","_ref7","addToQueue","callback","_len","args","Array","_key","push","runQueue","element","apply","setVisible","lockTextSelection","append","appendTo","remove","lockContextMenu","attr","removeAttr","lockPinchZoom","lock","$viewPortEl","originalValue","lockAllInteractions","reportFault","_ref8","reason","_ref9","reportKey","ttl","set","widgetId","_len2","_key2","getData","_ref10","response","registerNotifyDataListener"],"mappings":"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,eAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,KAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,IAAAmC,EAAA;;;;2SC9DAC,OAAOC,OAAU,WACf,aAGA,IAAMC,GACJC,SAAU,GACVC,SAAU,GACVC,KAAM,GACNC,WACAC,UAAW,IACXC,iBACAC,WAAW,EACXC,WAAW,EACXC,SAC4B,oBAAlBC,eACNA,oBACAC,EAMJC,aAAc,WACZ,MAAqB,IAAjBC,KAAKZ,UAAmC,IAAjBY,KAAKX,SACvBW,KAAKZ,SAAW,MAAQY,KAAKX,UAA0B,IAAbW,KAAKV,KAAc,IAAMU,KAAKV,KAAO,IAEjF,IAcTW,YAAa,SAASC,GAA+C,IAAAC,EAAAC,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAAxCE,EAAwCH,EAAxCG,KAAMf,EAAkCY,EAAlCZ,QAASgB,EAAyBJ,EAAzBI,KAAMC,EAAmBL,EAAnBK,KAAMC,EAAaN,EAAbM,MAItD,GAHaT,KAGJL,UAEmC,mBAA/Be,OAAOC,qBAChBD,OAAOC,qBAAqBT,EAAMK,EAAMC,GAIpB,mBAATA,GACTA,GACEI,OAAQ,IACRC,aAAc,WAVtB,CAmBA,IAAMC,EAtBOd,KAsBSD,eAAiBG,EACjCa,EAAaT,GAAe,MAC5BU,EAAczB,GAxBPS,KAwBiCT,QAGxC0B,EAAM,IAAIC,eAChBD,EAAIE,QA5BSnB,KA4BMR,UAEnByB,EAAIG,KAAKL,EAAWD,GAAU,GAGlB,QAARR,GACFW,EAAII,iBAAiB,eAAgB,kCAGvCL,EAAWM,QAAQ,SAACC,GAClBN,EAAII,iBAAiBE,EAAO/C,IAAK+C,EAAOrD,SAI1C,IAAIsD,EAAU,KACM,UAAhBC,EAAOlB,KACTiB,EAAUE,KAAKC,UAAUpB,IAI3BU,EAAIW,OAAS,WACPX,EAAIL,QAAU,KAAOK,EAAIL,QAAU,IACjB,mBAATJ,GACTA,EAAKR,MAGc,mBAAVS,GACTA,EAAMT,OAMZiB,EAAIY,KAAKL,MAKPM,GAEJC,eAAWjC,EAGXkC,eAEAC,eAAgB,SAASC,GACnBA,EAAI3B,MAAQ2B,EAAI3B,KAAK4B,KACD,iBAAlBD,EAAI3B,KAAK4B,MACXjD,OAAOkD,WAAWF,EAAI3B,KAAKA,KAAK8B,SAGlCC,QAAQC,IAAIL,IAIhBM,YAAa,YACXvD,OAAOwD,iBAAiB,UAAWzC,KAAKiC,gBAEpC9C,EAAKQ,YAGS,IAAI+C,iBAAiB,UAC7BD,iBAAkB,UAAW,SAACE,GACZ,kBAApBA,EAAMpC,KAAKD,KAEbpB,OAAOkD,WAAWO,EAAMpC,KAAK8B,SACA,gBAApBM,EAAMpC,KAAKD,OAEpBwB,EAAKE,YAAYW,EAAMpC,KAAK8B,SAAWM,EAAMpC,KAAKA,UAQtDqC,GAKJC,YAAa,SAASjD,GACpBT,EAAKS,SAAWA,GAOlBkD,aAAc,WAaZ,OAZAC,EAAEC,SAAW,SAASxF,GACpB,IAAMyF,EACJ,IAAIC,OAAO,OAAU1F,EAAO,aAAa2F,KAAKlE,OAAOmE,SAASC,MAChE,OAAe,MAAXJ,EACK,KAEAK,UAAUL,EAAQ,KAAO,GAIpC9D,EAAKO,WACFqD,EAAEC,SAAS,YAAwC,GAAzBD,EAAEC,SAAS,WACjC7D,EAAKO,WAOd6D,eAAgB,WAEd,GAAgC,oBAArBC,gBAET,OADArE,EAAKQ,WAAY,GACV,EAIT,IAAM8D,EAAe,IAAID,gBAAgBvE,OAAOmE,SAASM,QACzD,OAAID,EAAaE,IAAI,YAA6C,GAA/BF,EAAa3F,IAAI,YAClDqB,EAAKQ,WAAY,GACV,MAIL8D,EAAaE,IAAI,aACc,MAAjCF,EAAa3F,IAAI,eAEjBqB,EAAKQ,WAAY,GACV,IAiBXiE,OAAQ,WAAmD,IAAAC,EAAAzD,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAAzCf,EAAyCwE,EAAzCxE,SAAUC,EAA+BuE,EAA/BvE,KAAMC,EAAyBsE,EAAzBtE,QAASH,EAAgByE,EAAhBzE,SAEzCD,EAAKE,SAAWA,GAAsBF,EAAKE,SAC3CF,EAAKG,KAAOA,GAAcH,EAAKG,KAC/BH,EAAKI,QAAUA,GAAoBJ,EAAKI,QACxCJ,EAAKC,SAAWA,GAAsBD,EAAKC,UAS7C0E,KAAM,WAA6B,IAAAC,EAAA3D,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAAnBI,EAAmBuD,EAAnBvD,KAAMC,EAAasD,EAAbtD,MACpBtB,EAAKc,YACH,SAEEO,KAAMA,EACNC,MAAOA,KAabuD,QArGc,SAqGNC,GAAoC,IAAAC,EAAA9D,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAA7BR,EAA6BsE,EAA7BtE,SAAUY,EAAmB0D,EAAnB1D,KAAMC,EAAayD,EAAbzD,MAEvB0D,OAAyB,IAAZvE,EAA2BA,EAAWT,EAAKS,SAE9DT,EAAKc,YACH,YAEEK,KAAM,OACNC,MACE4D,GAAIA,EACJH,QAASC,GAEXzD,KAAMA,EACNC,MAAOA,KAYb2D,UA9Hc,WA8H0B,IAAAC,EAAAjE,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAA7BR,EAA6ByE,EAA7BzE,SAAUY,EAAmB6D,EAAnB7D,KAAMC,EAAa4D,EAAb5D,MAEnB0D,OAAyB,IAAZvE,EAA2BA,EAAWT,EAAKS,SAE9DT,EAAKc,YACH,oBAEEK,KAAM,OACNC,MACE4D,GAAIA,GAEN3D,KAAMA,EACNC,MAAOA,KAab6D,qBAvJc,SAuJOC,GAAwC,IAAAC,EAAApE,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAA7BR,EAA6B4E,EAA7B5E,SAAUY,EAAmBgE,EAAnBhE,KAAMC,EAAa+D,EAAb/D,MAExC0D,OAAyB,IAAZvE,EAA2BA,EAAWT,EAAKS,SAE9DT,EAAKc,YACH,oBAEEK,KAAM,OACNC,MACE4D,GAAIA,EACJI,SAAUA,GAEZ/D,KAAMA,EACNC,MAAOA,KAabgE,kBAjLc,SAiLIF,GAAwC,IAAAG,EAAAtE,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAA7BR,EAA6B8E,EAA7B9E,SAAUY,EAAmBkE,EAAnBlE,KAAMC,EAAaiE,EAAbjE,MAErC0D,OAAyB,IAAZvE,EAA2BA,EAAWT,EAAKS,SAE9DT,EAAKc,YACH,iBAEEK,KAAM,OACNC,MACE4D,GAAIA,EACJI,SAAUA,GAEZ/D,KAAMA,EACNC,MAAOA,KAUbkE,WAxMc,SAwMHC,GACc,mBAAZA,GACTtC,QAAQ7B,MAAM,6BAFY,QAAAoE,EAAAzE,UAAAC,OAANyE,EAAM,IAAAC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAANF,EAAME,EAAA,GAAA5E,UAAA4E,GAK5B7F,EAAKM,cAAcwF,MACjBL,SAAUA,EACVxE,UAAW0E,KAOfI,SAtNc,WAuNZ/F,EAAKM,cAAc6B,QAAQ,SAAC6D,GAC1BA,EAAQP,SAASQ,MAAMjG,EAAMgG,EAAQ/E,aAIvCjB,EAAKM,kBAMP4F,WAlOc,WAmOZlG,EAAKO,WAAY,EACjBM,KAAKkF,YAOPI,kBA3Oc,aA2OiBlF,UAAAC,OAAA,QAAAP,IAAAM,UAAA,KAAAA,UAAA,GAE3B2C,EAAE,6CAA6CwC,OAAO,sJAO/CC,SAAS,QAEhBzC,EAAE,mCAAmC0C,UAQzCC,gBA9Pc,aA8PetF,UAAAC,OAAA,QAAAP,IAAAM,UAAA,KAAAA,UAAA,GAEzB2C,EAAE,QAAQ4C,KAAK,gBAAiB,iBAEhC5C,EAAE,QAAQ6C,WAAW,kBAQzBC,cA1Qc,WA0Qa,IAAbC,IAAa1F,UAAAC,OAAA,QAAAP,IAAAM,UAAA,KAAAA,UAAA,GACnB2F,EAAchD,EAAE,4BACtB,GAAI+C,EAAM,CAER,IAAME,EAAgBD,EAAYJ,KAAK,WAGvCI,EAAYxF,KAAK,sBAAuByF,GACxCD,EAAYJ,KAAK,UACfK,EAAgB,kDAG6BlG,GAA3CiG,EAAYxF,KAAK,wBACnBwF,EAAYJ,KAAK,UAAWI,EAAYxF,KAAK,yBASnD0F,oBAhSc,WAgSmB,IAAbH,IAAa1F,UAAAC,OAAA,QAAAP,IAAAM,UAAA,KAAAA,UAAA,GAC/BJ,KAAKsF,kBAAkBQ,GACvB9F,KAAK0F,gBAAgBI,GACrB9F,KAAK6F,cAAcC,IAcrBI,YAjTc,WAoTZ,IAAAC,EAAA/F,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAFC6D,EAEDkC,EAFClC,KAAMmC,EAEPD,EAFOC,OAAQ5H,EAEf2H,EAFe3H,IAEf6H,EAAAjG,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MADCR,EACDyG,EADCzG,SAAUY,EACX6F,EADW7F,KAAMC,EACjB4F,EADiB5F,MAGX0D,OAAyB,IAAZvE,EAA2BA,EAAWT,EAAKS,SACxD0G,OAA2B,IAAP9H,EAAsBA,EAAM,UAAY2F,EAElEhF,EAAKc,YACH,UAEEK,KAAM,OACNC,MACE0D,KAAMA,EACNzF,IAAK8H,EACLF,OAAQA,EACRG,IAAK,IAEP/F,KAAMA,EACNC,MAAOA,KAWb+F,IA/Uc,SA+UVC,EAAUjJ,EAAMU,QACW,IAAlBiB,EAAKsH,KACdtH,EAAKsH,OAGPtH,EAAKsH,GAAUjJ,GAAQU,GASzBJ,IA7Vc,SA6VV2I,EAAUjJ,GACZ,OAAI2B,EAAKsH,SAA4C,IAAxBtH,EAAKsH,GAAUjJ,GACnC2B,EAAKsH,GAAUjJ,QAEtB,GAWJJ,KA5Wc,SA4WTqJ,EAAUjJ,GACb,GAAI2B,EAAKsH,IAA4C,mBAAxBtH,EAAKsH,GAAUjJ,GAAqB,SAAAkJ,EAAAtG,UAAAC,OAD3CyE,EAC2C,IAAAC,MAAA2B,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAD3C7B,EAC2C6B,EAAA,GAAAvG,UAAAuG,GAC/D,OAAOxH,EAAKsH,GAAUjJ,GAAM4H,MAAM,KAAMN,KAY5C8B,QA1Xc,SA0XNvE,GAA6B,IAAAwE,EAAAzG,UAAAC,OAAA,QAAAP,IAAAM,UAAA,GAAAA,UAAA,MAAnBI,EAAmBqG,EAAnBrG,KAAMC,EAAaoG,EAAbpG,MAClBtB,EAAKQ,UACHmC,EAAKE,YAAYK,GACC,mBAAT7B,GACTA,EAAK,IAAKsB,EAAKE,YAAYK,IAGR,mBAAV5B,GACTA,EAAM,IAAK,MAIftB,EAAKc,YACH,qBAAuBoC,GAErB/B,KAAM,MACNE,KAAM,SAASS,GACTT,GACFA,EAAKS,EAAIL,OAAQK,EAAI6F,WAGzBrG,MAAO,SAASQ,GACVR,GACFA,EAAMQ,EAAIL,YAatBwB,WA9Zc,SA8ZHC,GACLP,EAAK8C,UACP9C,EAAK8C,SAASvC,IAQlB0E,2BAxac,SAwaanC,GACzB9C,EAAK8C,SAAWA,IAapB,OARAhC,EAAQW,iBAGRzB,EAAKU,cAGLI,EAAQE,eAEDF,EAvkBQ","file":"xibo-interactive-control.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/xibo-interactive-control.js\");\n","/**\n * Copyright (C) 2020 Xibo Signage Ltd\n *\n * Xibo - Digital Signage - http://www.xibo.org.uk\n *\n * This file is part of Xibo.\n *\n * Xibo is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * any later version.\n *\n * Xibo is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with Xibo.  If not, see <http://www.gnu.org/licenses/>.\n */\nwindow.xiboIC = (function() {\n  'use strict';\n\n  // Private vars\n  const _lib = {\n    protocol: '', // default protocol\n    hostName: '', // default URL\n    port: '', // default PORT\n    headers: [], // Default headers\n    timelimit: 5000, // timelimit in milliseconds\n    callbackQueue: [],\n    isVisible: true, // Widget visibility on the player\n    isPreview: false, // If the library is being used by a preview\n    targetId:\n      (typeof xiboICTargetId != 'undefined') ?\n        xiboICTargetId :\n        undefined, // target id\n\n    /**\n     * Get URL string\n     * @return {string} URL string\n     */\n    getOriginURL: function() {\n      if (this.protocol != '' && this.hostName != '') {\n        return this.protocol + '://' + this.hostName + ((this.port != '') ? ':' + this.port : '');\n      }\n      return '';\n    },\n\n    /**\n     * Make a request to the configured server/player\n     * @param  {string} path - Request path\n     * @param  {Object} [options] - Optional params\n     * @param  {string} [options.type]\n     * @param  {Object[]} [options.headers]\n     *  Request headers in the format {key: key, value: value}\n     * @param  {Object} [options.data]\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    makeRequest: function(path, {type, headers, data, done, error} = {}) {\n      const self = this;\n\n      // Preview\n      if (self.isPreview) {\n        // Call the preview action if it exists\n        if (typeof parent.previewActionTrigger == 'function') {\n          parent.previewActionTrigger(path, data, done);\n        } else {\n          // Stop the method to avoid a request\n          // but send a fake response\n          if (typeof(done) == 'function') {\n            done({\n              status: 200,\n              responseText: 'OK',\n            });\n          }\n        }\n\n        // Stop the method to avoid a request\n        return;\n      }\n\n      const urlToUse = self.getOriginURL() + path;\n      const typeToUse = (type) ? type : 'GET';\n      const reqHeaders = (headers) ? headers : self.headers;\n\n      // Init AJAX\n      const xhr = new XMLHttpRequest();\n      xhr.timeout = self.timelimit;\n\n      xhr.open(typeToUse, urlToUse, true);\n\n      // Set headers\n      if (type == 'POST') {\n        xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n      }\n\n      reqHeaders.forEach((header) => {\n        xhr.setRequestHeader(header.key, header.value);\n      });\n\n      // Append data\n      let newData = null;\n      if (typeof(data) == 'object') {\n        newData = JSON.stringify(data);\n      }\n\n      // On load complete\n      xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          if (typeof(done) == 'function') {\n            done(this);\n          }\n        } else {\n          if (typeof(error) == 'function') {\n            error(this);\n          }\n        }\n      };\n\n      // Send!\n      xhr.send(newData);\n    },\n  };\n\n  // Interproccess communication\n  const _IPC = {\n    // Callback function of the widget\n    _callback: undefined,\n\n    // Data held in preview mode\n    previewData: {},\n\n    messageHandler: function(evt) {\n      if (evt.data && evt.data.ctrl) {\n        if (evt.data.ctrl === 'rtNotifyData') {\n          xiboIC.notifyData(evt.data.data.dataKey);\n        }\n      } else {\n        console.log(evt);\n      }\n    },\n\n    registerIPC: function() {\n      window.addEventListener('message', this.messageHandler);\n\n      if (_lib.isPreview) {\n        // In preview mode we register a broadcast channel which receives data and notify messages from the\n        // data connector user interface, if its open.\n        const channel = new BroadcastChannel('xiboDC');\n        channel.addEventListener ('message', (event) => {\n          if (event.data.type === 'xiboDC_notify') {\n            // Notify message\n            xiboIC.notifyData(event.data.dataKey);\n          } else if (event.data.type === 'xiboDC_data') {\n            // Record the data received.\n            _IPC.previewData[event.data.dataKey] = event.data.data;\n          }\n        });\n      }\n    },\n  };\n\n  // Public library\n  const mainLib = {\n    /**\n     * Set target id\n     * @param  {string} targetId - The target Id\n     */\n    setTargetId: function(targetId) {\n      _lib.targetId = targetId;\n    },\n\n    /**\n     * Check if the current widget is visible\n     * @return {boolean} Widget visibility\n     */\n    checkVisible: function() { // Check if the widget is hidden or visible\n      $.urlParam = function(name) {\n        const results =\n          new RegExp('[\\?&]' + name + '=([^&#]*)').exec(window.location.href);\n        if (results == null) {\n          return null;\n        } else {\n          return decodeURI(results[1]) || 0;\n        }\n      };\n\n      _lib.isVisible =\n        ($.urlParam('visible')) ? ($.urlParam('visible') == 1) : true;\n      return _lib.isVisible;\n    },\n\n    /**\n     * Check if we're running in a preview\n     * @return {boolean} Preview status\n     */\n    checkIsPreview: function() {\n      // If we don't have URLSearchParams defined, we're also in preview\n      if (typeof(URLSearchParams) === 'undefined') {\n        _lib.isPreview = true;\n        return true;\n      }\n\n      // Check if we have the preview flag in URL\n      const searchParams = new URLSearchParams(window.location.search);\n      if (searchParams.has('preview') && searchParams.get('preview') == 1) {\n        _lib.isPreview = true;\n        return true;\n      }\n\n      // For the widget preview in viewer\n      if (searchParams.has('isEditor') &&\n        searchParams.get('isEditor') === '1'\n      ) {\n        _lib.isPreview = true;\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * Configure the library options\n     * @param  {Object} [options]\n     * @param  {string} [options.hostName]\n     * @param  {string} [options.port]\n     * @param  {Object[]} [options.headers]\n     *  Request headers in the format {key: key, value: value}\n     * @param  {string} [options.headers.key]\n     * @param  {string} [options.headers.value]\n     * @param  {string} [options.protocol]\n     */\n    config: function({hostName, port, headers, protocol} = {}) {\n      // Initialise custom request params\n      _lib.hostName = hostName ? hostName : _lib.hostName;\n      _lib.port = port ? port : _lib.port;\n      _lib.headers = headers ? headers : _lib.headers;\n      _lib.protocol = protocol ? protocol : _lib.protocol;\n    },\n\n    /**\n     * Get player info\n     * @param  {Object[]} [options] - Request options\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    info: function({done, error} = {}) {\n      _lib.makeRequest(\n        '/info',\n        {\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Trigger a predefined action\n     * @param  {string} code - The trigger code\n     * @param  {string} [options.targetId] - target id\n     * @param  {Object[]} [options] - Request options\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    trigger(code, {targetId, done, error} = {}) {\n      // Get target id from the request option or from the global lib var\n      const id = (typeof targetId != 'undefined') ? targetId : _lib.targetId;\n\n      _lib.makeRequest(\n        '/trigger',\n        {\n          type: 'POST',\n          data: {\n            id: id,\n            trigger: code,\n          },\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Expire widget\n     * @param  {Object[]} [options] - Request options\n     * @param  {string} [options.targetId] - target id\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    expireNow({targetId, done, error} = {}) {\n      // Get target id from the request option or from the global lib var\n      const id = (typeof targetId != 'undefined') ? targetId : _lib.targetId;\n\n      _lib.makeRequest(\n        '/duration/expire',\n        {\n          type: 'POST',\n          data: {\n            id: id,\n          },\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Extend widget duration\n     * @param  {string} duration - Duration value to extend\n     * @param  {Object[]} [options] - Request options\n     * @param  {string} [options.targetId] - target id\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    extendWidgetDuration(duration, {targetId, done, error} = {}) {\n      // Get target id from the request option or from the global lib var\n      const id = (typeof targetId != 'undefined') ? targetId : _lib.targetId;\n\n      _lib.makeRequest(\n        '/duration/extend',\n        {\n          type: 'POST',\n          data: {\n            id: id,\n            duration: duration,\n          },\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Set widget duration\n     * @param  {string} duration - New widget duration\n     * @param  {Object[]} [options] - Request options\n     * @param  {string} [options.targetId] - target id\n     * @param  {callback} [options.done]\n     * @param  {callback} [options.error]\n     */\n    setWidgetDuration(duration, {targetId, done, error} = {}) {\n      // Get target id from the request option or from the global lib var\n      const id = (typeof targetId != 'undefined') ? targetId : _lib.targetId;\n\n      _lib.makeRequest(\n        '/duration/set',\n        {\n          type: 'POST',\n          data: {\n            id: id,\n            duration: duration,\n          },\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Add callback function to the queue\n     * @param  {callback} callback - Function to store\n     * @param  {Object[]} [args] - Function arguments\n     */\n    addToQueue(callback, ...args) {\n      if (typeof callback != 'function') {\n        console.error('Invalid callback function');\n      }\n\n      _lib.callbackQueue.push({\n        callback: callback,\n        arguments: args,\n      });\n    },\n\n    /**\n     * Run promised functions in queue\n     */\n    runQueue() {\n      _lib.callbackQueue.forEach((element) => {\n        element.callback.apply(_lib, element.arguments);\n      });\n\n      // Empty queue\n      _lib.callbackQueue = [];\n    },\n\n    /**\n     * Set visible and run queue\n     */\n    setVisible() {\n      _lib.isVisible = true;\n      this.runQueue();\n    },\n\n    /**\n     * Lock text selection\n     * @param  {Object} lock - Lock (true) or unlock (false)\n     */\n    lockTextSelection(lock = true) {\n      if (lock) {\n        $('<style class=\"lock-text-selection-style\">').append('* {' +\n          '-webkit-touch-callout: none;' +\n          '-webkit-user-select: none;' +\n          '-khtml-user-select: none;' +\n          '-moz-user-select: none;' +\n          '-ms-user-select: none;' +\n          'user-select: none;' +\n          '}').appendTo('head');\n      } else {\n        $('style.lock-text-selection-style').remove();\n      }\n    },\n\n    /**\n     * Lock context menu\n     * @param {boolean} lock - Lock (true) or unlock (false)\n     */\n    lockContextMenu(lock = true) {\n      if (lock) {\n        $('body').attr('oncontextmenu', 'return false;');\n      } else {\n        $('body').removeAttr('oncontextmenu');\n      }\n    },\n\n    /**\n     * Lock pinch zoom\n     * @param {boolean} lock - Lock (true) or unlock (false)\n     */\n    lockPinchZoom(lock = true) {\n      const $viewPortEl = $('head > [name=\"viewport\"]');\n      if (lock) {\n        // Get original value\n        const originalValue = $viewPortEl.attr('content');\n\n        // Backup value as data\n        $viewPortEl.data('viewportValueBackup', originalValue);\n        $viewPortEl.attr('content',\n          originalValue + ' maximum-scale=1.0, user-scalable=no');\n      } else {\n        // Restore value\n        if ($viewPortEl.data('viewportValueBackup') != undefined) {\n          $viewPortEl.attr('content', $viewPortEl.data('viewportValueBackup'));\n        }\n      }\n    },\n\n    /**\n     * Lock all properties\n     * @param {boolean} lock - Lock (true) or unlock (false)\n     */\n    lockAllInteractions(lock = true) {\n      this.lockTextSelection(lock);\n      this.lockContextMenu(lock);\n      this.lockPinchZoom(lock);\n    },\n\n    /**\n     * Report fault on requested data\n     * @param {Object[]} [params] - Parameters\n     * @param {string} [params.code] - Fault code\n     * @param {string} [params.reason] - Fault reason\n     * @param {string} [params.key] - Optional key\n     * @param {Object[]} [options] - Request options\n     * @param {string} [options.targetId] - Target id\n     * @param {callback} [options.done]\n     * @param {callback} [options.error]\n     */\n    reportFault(\n      {code, reason, key} = {},\n      {targetId, done, error} = {},\n    ) {\n      // Get target id from the request option or from the global lib var\n      const id = (typeof targetId != 'undefined') ? targetId : _lib.targetId;\n      const reportKey = (typeof key != 'undefined') ? key : 'xiboIC_' + id;\n\n      _lib.makeRequest(\n        '/fault',\n        {\n          type: 'POST',\n          data: {\n            code: code,\n            key: reportKey,\n            reason: reason,\n            ttl: 60,\n          },\n          done: done,\n          error: error,\n        },\n      );\n    },\n\n    /**\n     * Set global lib var/method\n     * @param {string} widgetId - Widget id\n     * @param {string} name - Name of the var/method\n     * @param {any} value - Value of the var/method\n     */\n    set(widgetId, name, value) {\n      if (typeof _lib[widgetId] == 'undefined') {\n        _lib[widgetId] = {};\n      }\n\n      _lib[widgetId][name] = value;\n    },\n\n    /**\n     * Get global lib var/method\n     * @param {string} widgetId - Widget id\n     * @param {string} name - Name of the var/method\n     * @return {any} Value of the var/method\n     */\n    get(widgetId, name) {\n      if (_lib[widgetId] && typeof _lib[widgetId][name] != 'undefined') {\n        return _lib[widgetId][name];\n      } else {\n        return undefined;\n      }\n    },\n\n    /**\n     * Call global lib method\n     * @param {string} widgetId - Widget id\n     * @param {string} name - Name of the method\n     * @param {any[]} args - Arguments of the method\n     * @return {any} Value of the method\n     */\n    call(widgetId, name, ...args) {\n      if (_lib[widgetId] && typeof _lib[widgetId][name] == 'function') {\n        return _lib[widgetId][name].apply(null, args);\n      }\n    },\n\n    // Realtime data\n    /**\n     * Get realtime data from the player. Called from the widget.\n     * @param {string} dataKey The key where this data is expected to be stored\n     * @param {Object} [options] - Request options\n     * @param {callback} [options.done]\n     * @param {callback} [options.error]\n     */\n    getData(dataKey, {done, error} = {}) {\n      if (_lib.isPreview) {\n        if (_IPC.previewData[dataKey]) {\n          if (typeof done === 'function') {\n            done(200, _IPC.previewData[dataKey]);\n          }\n        } else {\n          if (typeof error === 'function') {\n            error(404, null);\n          }\n        }\n      } else {\n        _lib.makeRequest(\n          '/realtime?dataKey=' + dataKey,\n          {\n            type: 'GET',\n            done: function(xhr) {\n              if (done) {\n                done(xhr.status, xhr.response);\n              }\n            },\n            error: function(xhr) {\n              if (error) {\n                error(xhr.status);\n              }\n            },\n          },\n        );\n      }\n    },\n\n    /**\n     * Called by the native player host when an associated data connector\n     * notifies that it has changed data on the key provided\n     * @param {string} dataKey The data key\n     */\n    notifyData(dataKey) {\n      if (_IPC.callback) {\n        _IPC.callback(dataKey);\n      }\n    },\n\n    /**\n     * Register callback function. Called by widget\n     * @param {callback} callback\n     */\n    registerNotifyDataListener(callback) {\n      _IPC.callback = callback;\n    },\n  };\n\n  // Check if it's a preview\n  mainLib.checkIsPreview();\n\n  // Register the IPC handler\n  _IPC.registerIPC();\n\n  // Check visibility on load\n  mainLib.checkVisible();\n\n  return mainLib;\n})();\n"],"sourceRoot":""}